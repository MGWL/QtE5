QtE5 — Обёртка Qt-5 для DMD.


----------- Перехват нажатия кнопок ---------

1)- Перехват нажатия кнопок в QPlainTextEdit.setKeyPressEvent(&onChar);
	Сложная тема. Основной алгоритм построен следуюим образом.
	В объекте QPlainTextEdit переопределен виртуальный метод keyPressEvent(QKeyEvent *event),
	таким образом, что если мы с QtE5 не установили обработчик, то всё будет работать по умолчанию.
	Если мы переопределим обработчик своей функцией, то наша функция должна возвращать
	bool T при условии, что мы хотим обработать событие и F если мы заблокируем обработку.
Пример:

// Проверка события KeyPressEvent 
bool onChar(void* ev) {
	// 1 - Схватить событие пришедшее из Qt и сохранить его в моём классе. «+» в параметре говорит о 
	// том, что не надо создавать экземпляр Qt5 QkeyEvent(), а взять его с входного параметра и сохранить
	// в объекте. Это что бы было легче обрабатывать это событие, используя свои обертки из QtE5
	QKeyEvent qe = new QKeyEvent('+', ev); 
	// 2 - Выдать тип события, используя описание события 
	writeln(qe.type, "  -- key -> ", qe.key, "  -- count -> ", qe.count);
	// 3 — Если была нажата A (65 скан код) то мы запретим обработку данного события
	if(qe.key == 65) return false;
	return true;
}
….
// 2 — Делаем  QplainTextEdit и переопределим у него обработку событий нажатия клавиатуры, перенеся
// обработку в  bool onChar(), причем нужно возвращать параметр в С++, что бы событие было обработано
	QPlainTextEdit te1 = new QplainTextEdit(null); te1.setKeyPressEvent(&onChar);

----------- Вызов методов из слотов ---------

2) - Вызов метода из функции определенной для слота. Основная задача избавится от глобальных переменных.

	// Это наш обработчик события. В нём осуществляется вызов метода класса CTest
	void test2(CTest* z) {
		(*z).Method();
	}
	class CTest {
		this() {
			QSlot slotKn1 = new QSlot(&test2, aThis); // А что, пусть так и будет!
			connect(pb1.QtObj, MSS("clicked()", QSIGNAL), slotKn1.QtObj, MSS("Slot()", QSLOT));

		....
		void Method() {
		}
	}
    CTest1 w1 = new CTest(); w1.saveThis(&w1);  // обязательно сохранить указатель используя saveThis()

	Для этого описываем класс и в нем метод, который мы вызовем из test2()
